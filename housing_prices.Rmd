---
title: 'Data analytics for the Ames Housing Dataset'
output:
  html_document:
    code_folding: hide
    css: style.css
    highlight: tango
    number_sections: true
    theme: yeti
    toc: true
    toc_depth: 2
editor_options:
  chunk_output_type: console
---

```{js, echo = FALSE}
// Add the Kaggle competition banner to the top of the page.
let banner_html = '<img id="banner" src="images/housesbanner.png" alt="Banner">';
header = document.getElementById('header');
header.innerHTML = banner_html + header.innerHTML;
```

```{r setup, message=FALSE, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    fig.align = 'center',
    comment = NA
)

library(dplyr)
library(DT)
library(ggplot2)
library(latex2exp)
library(purrr)
library(scales)
library(tidyr)
```

# Exploratory data analysis / feature engineering

Feature engineering was done in an iterative process.

  - Individual predictor variables that could explain variance in the target
    were plotted against the target.
  - Variables were transformed and/or new variables were defined to try to
    enhance linear associations visible in the plots.

Outcome:

  1. The target (SalePrice) and one predictor (GrLivArea: Above ground living
     area) were both transformed using the logarithm.
  2. The predictors YearBuilt and GarageYrBlt were transformed using the
     function $f(x) = (x - 1900)^3$.


## Missing data {.tabset}

### Summary {.unnumbered}

'NA' was replaced by a string such as 'NB' for 'No Basement' in cases where it
represented a valid category.

  - From the variable descriptions provided in *data_description.txt*, NA is a
    valid category for certain columns. Preprocessing with the script
    *preprocess.R* replaced these NA strings so that they would not be treated
    as missing values.

After this preprocessing, missing values were concentrated in only a few
variables.

### Missing value counts {.tab-display .unnumbered}

<div class="code-block">

```{r, missing-data}
source('descriptions.R')
read_data <- function(file) {
    data <- read.csv(file, stringsAsFactors = F)
    return(data)
}
train_data <- read_data('data/train.csv')
test_data <- read_data('data/test.csv')
get_na_counts <- function(data, dataset_name) {
    na_counts <- data.frame(name = colnames(data),
                            count = colSums(is.na(data)),
                            dataset = dataset_name,
                            stringsAsFactors = F) %>%
        arrange(desc(count)) %>%
        filter(count != 0)
    return(na_counts)
}

na_counts_train <- get_na_counts(train_data, 'train')
na_counts_test <- get_na_counts(test_data, 'test')
combined_na_counts <- rbind(na_counts_test, na_counts_train,
                            make.row.names = F) %>%
    arrange(desc(count), desc(dataset), name) %>%
    rename(`missing value count` = count)

# The same (complicated) set of options can be used with DT::datatable
# throughout this file.  A function wrapper is defined for this.
get_datatable <- function(data) {
    table_alignment <- list(className = 'dt-center', targets = '_all')
    table_with_options <- datatable(
        data,
        rownames = F,
        options = list(columnDefs = list(table_alignment), digits = 3)
    )
    return(table_with_options)
}
get_datatable(combined_na_counts)
```

</div>

## Variable distributions {.tabset}

### Summary {.unnumbered}

The tabs show the distribution of each variable.

  - Numeric predictors with only a few values are labeled as discrete, while
    those with many values are labeled as continuous.
  - For variables that were transformed, the distributions before and after the
    transformation are both shown, along with the formula for the
    transformation.
  - The variable descriptions from *data_description.txt* are included with the
    plots.

Transformation of the target variable and the predictor variable GrLivArea
decreased skew.

Several variables have a distribution concentrated into a single value or a
small subset of the values.

  - For example, most houses have zero pool area.

### Target {.tab-display .unnumbered}

<div class="code-block">

```{r, plot-target, cache=TRUE}
# Enclose the commands in curly braces to keep the code output in a single
# block.
{
    to_plot <- select(train_data, SalePrice) %>%
        mutate(SalePrice = SalePrice / 1000)
    fig <- ggplot(to_plot,
                  aes(x = SalePrice)) +
        geom_histogram(fill = 'navyblue', bins = 30) +
        scale_x_continuous(name = 'SalePrice',
                           labels = label_dollar(suffix = 'k')) +
        ggtitle('SalePrice')
    print(fig)

    train_data <- mutate(train_data, SalePrice = log(SalePrice))
    fig <- ggplot(select(train_data, SalePrice),
                  aes(x = SalePrice)) +
        geom_histogram(fill = 'navyblue', bins = 30) +
        scale_x_continuous(name = 'log(SalePrice)') +
        ggtitle('log(SalePrice)')
    print(fig)
    cat('transformation:  ', 'price -> log(price)', '\n\n')
}
```

</div>
### Discrete predictors {.tab-display .unnumbered}

<div class="code-block">

```{r, discrete-distributions, cache=TRUE}
# Given a vector of variable names, reorder the names to match the order used in
# the original data set (i.e., in csv files and data_description.txt).
all_column_names <- colnames(train_data)
reorder_names <- function(variable_names) {
    reorder_index <- order(match(variable_names, all_column_names))
    variable_names <- variable_names[reorder_index]
}

# For numeric variables with only a few values (such as YrSold), it is not
# initially clear whether the variable should be treated as categorical or
# numeric in, say, a linear model.  For plots, however, it is natural to treat
# these variables as categorical initially.
#
# Define three classes of variables:  categorical, continuous, and discrete
# numeric.  Here 'continuous' is used for numeric variables containing many
# values.

# Note that MSSubClass is a nominal variable labeled with nonconsecutive integer
# values, and it should be treated as categorical.
train_data <- mutate(train_data, MSSubClass = as.factor(MSSubClass))
categorical_predictors <- reorder_names(colnames(
    select(train_data, where(is.character), MSSubClass)
))

discrete_numeric <- reorder_names(c(
    'OverallQual', 'OverallCond', 'BsmtFullBath', 'BsmtHalfBath', 'FullBath',
    'HalfBath', 'BedroomAbvGr', 'KitchenAbvGr', 'TotRmsAbvGrd', 'Fireplaces',
    'GarageCars', 'MoSold', 'YrSold'
))

continuous_predictors <- reorder_names(setdiff(
    all_column_names,
    c(categorical_predictors, discrete_numeric, 'Id', 'SalePrice')
))

# Helper function that finds the total number of characters needed for the
# labels on the horizontal axis.  If this number is too large, the labels are
# rotated.
nchar_labels <- function(vector_to_plot) {
    # Drop missing values.
    vector_to_plot <- vector_to_plot[!is.na(vector_to_plot)]
    char_vector <- as.character(vector_to_plot)
    label_lengths <- nchar(unique(char_vector))
    return(sum(label_lengths))
}

# Helper function that rotates the labels of the horizontal axis if necessary.
set_label_angle <- function(fig, vector_to_plot) {
    if (nchar_labels(vector_to_plot) > 60) {
        fig <- fig + theme(
            axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
        )
    }
    return(fig)
}

# Helper function used in setting x-axis labels.
get_discrete_values <- function(vector_to_plot) {
    axis_labels <- seq(min(vector_to_plot),
                       max(vector_to_plot))
    return(axis_labels)
}

to_plot_categorical <- reorder_names(
    c(categorical_predictors, discrete_numeric)
)
for (variable_name in to_plot_categorical) {
    # The list variable_descriptions is defined in 'descriptions.R'
    description <- variable_descriptions[[variable_name]]
    to_plot <- select(train_data, all_of(variable_name)) %>%
        drop_na()

    # In cases where the variable is an integer, converting it to a factor
    # before plotting decreases the amount of tweaking that is needed for the
    # plot.  However, there may be missing values in the horizontal axis.  In
    # the training set, for instance, there are no samples that have 7
    # bedrooms above ground, so 6 ends up next to 8 without special handling.
    # In order to avoid this, use the limits argument of scale_x_discrete.
    is_int <- is.integer(to_plot[[variable_name]])
    if (is_int) {
        x_axis_labels <- get_discrete_values(to_plot[[variable_name]]) %>%
            as.character
        to_plot[[variable_name]] <- as.factor(to_plot[[variable_name]])
    }

    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        geom_bar(fill = 'navyblue') +
        ggtitle(variable_name)
    if (is_int) {
        fig <- fig + scale_x_discrete(limits = x_axis_labels)
    } else {
        fig <- set_label_angle(fig, to_plot[[variable_name]])
    }
    print(fig)
    cat(description)
}
```

</div>

### Continuous predictors {.tab-display .unnumbered}

<div class="code-block">

```{r, continuous-distributions, cache=TRUE}
# Function used for transforming YearBuilt and GarageYrBlt
transform_year <- function(x) {
    return((x - 1900)^3)
}
transform_year_formula <- 'year -> (year - 1900)^3'

# The information associated with transforming variables is entered as a list
# of lists.  In order to avoid awkward syntax in accessing elements of nested
# list, however, the nested list is used to generated simple 1D lists and
# vectors.  (The reason for using the nested list initially is to group
# together the information for a particular variable.)
transformations <- list(
    GrLivArea = list(func = log,
                     label = 'log(GrLivArea)',
                     formula = 'area -> log(area)'),
    YearBuilt = list(func = transform_year,
                     label = 'transformed YearBuilt',
                     formula = transform_year_formula),
    GarageYrBlt = list(func = transform_year,
                       label = 'transformed GarageYrBlt',
                       formula = transform_year_formula)
)
transformed_variables <- names(transformations)
transformed_variable_labels <- map_chr(transformations, ~ (.)$label)
transformation_functions <- map(transformations, ~ (.)$func)
transformation_formulas <- map_chr(transformations, ~ (.)$formula)

get_variable_label <- function(variable_name) {
    if (variable_name %in% transformed_variables) {
        variable_label <- transformed_variable_labels[variable_name]
    } else {
        variable_label <- variable_name
    }
    return(variable_label)
}

for (variable_name in continuous_predictors) {
    description <- variable_descriptions[[variable_name]]
    to_plot <- select(train_data, all_of(variable_name)) %>%
        drop_na()

    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        geom_histogram(fill = 'navyblue', bins = 30) +
        ggtitle(variable_name)
    print(fig)

    if (variable_name %in% transformed_variables) {
        # Apply the transformation to the variable.
        func <- transformation_functions[[variable_name]]
        formula <- transformation_formulas[variable_name]
        train_data[[variable_name]] <- func(
            train_data[[variable_name]]
        )

        variable_label <- get_variable_label(variable_name)
        fig <- ggplot(drop_na(train_data[variable_name]),
                      aes_string(x = variable_name)) +
            geom_histogram(fill = 'navyblue', bins = 30) +
            scale_x_continuous(name = variable_label) +
            ggtitle(variable_label)
        print(fig)

        cat('transformation:  ', formula, '\n\n')
    }

    cat(description)
}
```

</div>

## Variable associations

### Which predictors can explain the variance in the sale price? {.tabset}

#### Summary {.unnumbered}

ANOVA ($\eta^2$) used for nominal predictors.

$R^2$ used for numeric predictors.

For many of the predictors that individually explain the largest fraction of
variance, the value of $\eta^2$ or $R^2$ was increased by the transformations.

  - Example:  the highest value of $R^2$ (OverallQual) increased from 0.63 to
    0.67 due to the transformation of SalePrice.

#### Nominal predictors {.tab-display .unnumbered}

<div class="code-block">

```{r, eta-squared, cache=TRUE}
get_simple_model <- function(variable_name) {
    # For categorical variables, perform ANOVA and return eta squared along
    # with predictions based on the model.  For numeric variables, do a simple
    # linear regression and return R squared along with predictions.
    #
    # Note that the command aov used for ANOVA in R is a wrapper to lm that
    # provides a summary in the traditional ANOVA form.  This summary doesn't
    # include eta squared.  However, the value is available as r.squared from
    # the summary for lm.  So if aov is used to generate the model, then eta
    # squared is available as summary.lm(model)$r.squared.
    #
    # In the current function, use the lm command both for categorical and
    # numeric predictors.
    model_formula <- as.formula(paste0('SalePrice ~ ', variable_name))
    model <-  lm(model_formula, train_data)
    results <- list(
        r_squared = summary(model)$r.squared,
        prediction = predict(model, na.action = na.omit)
    )
    return(results)
}

anova_models <- map(categorical_predictors, get_simple_model)
names(anova_models) <- categorical_predictors
eta_squared_vec <- map_dbl(anova_models, ~ (.)$r_squared)
eta_squared_df <- data.frame(name = categorical_predictors,
                             eta.squared = eta_squared_vec,
                             stringsAsFactors = F) %>%
    arrange(desc(eta.squared)) %>%
    rename(`eta squared` = eta.squared)
get_datatable(eta_squared_df) %>%
    formatRound(columns = 'eta squared', digits = 3)
```

</div>

#### Numeric predictors  {.tab-display .unnumbered}

<div class="code-block">

```{r, r-squared, cache=TRUE}
r_squared_variables <- reorder_names(
    c(continuous_predictors, discrete_numeric)
)

simple_linear_models <- map(r_squared_variables, get_simple_model)
names(simple_linear_models) <- r_squared_variables
simple_linear_prediction <- map(simple_linear_models, ~ (.)$prediction)
r_squared_vec <- map_dbl(simple_linear_models, ~ (.)$r_squared)
r_squared_df <- data.frame(name = r_squared_variables,
                           r.squared = r_squared_vec) %>%
    arrange(desc(r.squared)) %>%
    rename(`R squared` = r.squared)
get_datatable(r_squared_df) %>%
    formatRound(columns = 'R squared', digits = 3)
```

</div>

### Plots of sale price vs individual predictors {#association-plots .tabset}

#### Summary {.unnumbered}

Predictors with large $\eta^2$ or $R^2$ are plotted against sale price.

  - Here "large" is defined to mean $\gtrsim 0.1$.
  - For both $\eta^2$ and $R^2$, there is a gap in the values at around 0.1, and
    predictors falling above the gap are plotted.
  - Predictor distributions and descriptions are also shown.

The linear profile of several of the predictors improved dramatically due to
the transformation of SalePrice.

  - For example, the transformation caused the median values shown in many of
    the box plots to fall roughly on a line.


#### Box plots {.tab-display .unnumbered}

<div class="code-block">

```{r, box-plots, cache=TRUE}
large_eta_squared <- filter(eta_squared_df, `eta squared` >= 0.085)
for (variable_name in large_eta_squared[['name']]) {
    eta_squared <- round(eta_squared_vec[variable_name], digits = 3)
    description <- variable_descriptions[[variable_name]]
    to_plot <- select(train_data, SalePrice, all_of(variable_name)) %>%
        drop_na()
    to_plot[[variable_name]] <- as.factor(to_plot[[variable_name]]) %>%
        reorder(to_plot[['SalePrice']], median)

    plot_title <- paste0(variable_name, ', ', '$\\eta^2 = ', eta_squared, '$')
    fig <- ggplot(to_plot, aes_string(x = variable_name, y = 'SalePrice')) +
        geom_boxplot(aes_string(fill = variable_name)) +
        scale_y_continuous(name = 'log(SalePrice)') +
        scale_x_discrete(name = variable_name) +
        scale_fill_discrete(name = variable_name) +
        ggtitle(TeX(plot_title))
    fig <- set_label_angle(fig, to_plot[[variable_name]])
    print(fig)

    # Bar chart of the distribution
    plot_title <- paste(variable_name, 'distribution')
    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        geom_bar(fill = 'navyblue') +
        scale_x_discrete(name = variable_name) +
        ggtitle(plot_title)
    fig <- set_label_angle(fig, to_plot[[variable_name]])
    print(fig)

    cat(description)
}
```

</div>

#### Scatter plots {.tab-display .unnumbered}

<div class="code-block">

```{r, scatter-plots, cache=TRUE}
large_r_squared <- filter(r_squared_df, `R squared` >= 0.095)
for (variable_name in large_r_squared[['name']]) {
    r_squared <- round(r_squared_vec[variable_name], digits = 3)
    description <- variable_descriptions[[variable_name]]
    prediction <- simple_linear_prediction[[variable_name]]
    to_plot <- select(train_data, SalePrice, all_of(variable_name)) %>%
        drop_na() %>%
        mutate(PredictedPrice = prediction)

    # Scatter plot
    variable_label <- get_variable_label(variable_name)
    plot_title <- paste0(
        variable_label, ', ', '$R^2 = ', r_squared, '$'
    )
    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        geom_point(aes(y = SalePrice, color = 'data')) +
        geom_line(aes(y = PredictedPrice, color = 'fit')) +
        scale_color_manual(
            name = NULL,
            values = c(
                'data' = 'navyblue',
                'fit' = 'red'
            )) +
        scale_y_continuous(name = 'log(SalePrice)') +
        ggtitle(TeX(plot_title))

    is_discrete <- variable_name %in% discrete_numeric
    if (is_discrete) {
        breaks <- get_discrete_values(to_plot[[variable_name]])
        labels <- as.character(breaks)
        fig <- fig + scale_x_continuous(
            name = variable_label, breaks = breaks, labels = labels
        )
    } else {
        fig <- fig + scale_x_continuous(name = variable_name)
    }
    print(fig)

    # Histogram or bar chart of the distribution
    plot_title <- paste(variable_label, 'distribution')
    if (is_discrete) {
        to_plot[[variable_name]] <- as.factor(to_plot[[variable_name]])
        fig <- ggplot(to_plot, aes_string(x = variable_name)) +
            geom_bar(fill = 'navyblue') +
            scale_x_discrete(limits = labels)
    } else {
        fig <- ggplot(to_plot, aes_string(x = variable_name)) +
            geom_histogram(fill = 'navyblue', bins = 30) +
            scale_x_continuous(name = variable_label)
    }
    print(fig + ggtitle(plot_title))

    if (variable_name %in% transformed_variables) {
        cat('transformation:  ',
            transformation_formulas[variable_name],
            '\n\n'
        )
    }
    cat(description)
}
```

</div>
