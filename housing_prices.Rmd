---
title: 'Data analytics for the Ames Housing Dataset'
output:
  html_document:
    code_folding: hide
    css: style.css
    highlight: tango
    number_sections: true
    theme: yeti
    toc: true
    toc_depth: 2
editor_options:
  chunk_output_type: console
---

```{js, echo = FALSE}
// Add the Kaggle competition banner to the top of the page.
let banner_html =  '<img id="banner" src="images/housesbanner.png" alt="Banner">';
header = document.getElementById('header');
header.innerHTML = banner_html + header.innerHTML;
```

```{r setup, message=FALSE, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    fig.align = 'center',
    comment = NA
)

library(dplyr)
library(DT)
library(ggplot2)
library(scales)
library(tidyr)
```

# Exploratory Data Analysis

## Missing data {.tabset}

### Summary {.unnumbered}

'NA' was replaced by 'null' in cases where it represented a valid value.

  - From the variable descriptions provided in *data_description.txt*, NA is
  a valid value for certain categorical columns. Preprocessing with the
  script *preprocess.R* replaced these NA values by the string 'null' so that
  they would not be treated as missing values.

After this preprocessing, missing values are concentrated in only four
variables

  - LotFrontage: Linear feet of street connected to property
  - GarageYrBlt: Year garage was built
  - MasVnrType: Masonry veneer type
  - MasVnrArea: Masonry veneer area in square feet

### Data {.tab-display .unnumbered}

<div class="code-block">

```{r}
source('descriptions.R')
read_data <- function(file) {
    data <- read.csv(file, stringsAsFactors = F,
                     colClasses = c(MSSubClass = 'character'))
    return(data)
}
train_data <- read_data('data/train.csv')
test_data <- read_data('data/test.csv')
get_na_counts <- function(data, dataset_name) {
    na_counts <- data.frame(name = colnames(data),
                            count = colSums(is.na(data)),
                            dataset = dataset_name,
                            stringsAsFactors = F) %>%
        arrange(desc(count)) %>%
        filter(count != 0)
    return(na_counts)
}

na_counts_train <- get_na_counts(train_data, 'train')
na_counts_test <- get_na_counts(test_data, 'test')
combined_na_counts <- rbind(na_counts_test, na_counts_train,
                            make.row.names = F) %>%
    arrange(desc(count), desc(dataset), name) %>%
    rename(`missing value count` = count)

# Define option for column alignment to be passed to DT::datatable.
table_alignment <- list(className = 'dt-center', targets = '_all')
datatable(combined_na_counts, rownames = F,
          options = list(columnDefs = list(table_alignment)
))
```

</div>

## Variable distributions {.tabset}

### Summary {.unnumbered}

The tabs show the distribution of each variable, in order to give a feel for the
variables.

  - Bar charts are used for categorical (nominal) variables.
  - Histograms are used for numerical variables.
  - The variable descriptions from *data_description.txt* are included with the plots.

The target variable (SalePrice) is skewed right.

A number of the predictor variables are concentrated into a single value or a
small range of values.  Examples:

  - Most houses have all public utilities.
  - Most house have no pool area.

### Target {.tab-display .unnumbered}

<div class="code-block">

```{r}
to_plot <- select(train_data, SalePrice)
fig <- ggplot(to_plot, aes(x = SalePrice)) +
    geom_histogram(fill = 'navyblue', bins = 30) +
    scale_x_continuous(name = 'Price', labels = label_dollar()) +
    ggtitle('SalePrice')
print(fig)
```

</div>
### Categorical predictors {.tab-display .unnumbered}

<div class="code-block">

```{r}
# Helper function that finds the total number of characters needed for the
# labels on the horizontal axis.  If this number is too large, the labels will
# be rotated.
nchar_labels <- function(char_vector) {
    char_vector <- char_vector[!is.na(char_vector)]
    label_lengths <- nchar(unique(char_vector))
    return(sum(label_lengths))
}

nominal_predictors <- colnames(
    select(train_data, where(is.character))
)

for (variable_name in nominal_predictors) {
    # The list variable_descriptions is defined in 'descriptions.R'
    description <- variable_descriptions[[variable_name]]
    to_plot <- select(train_data, all_of(variable_name)) %>%
        drop_na()

    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        geom_bar(fill = 'navyblue') +
        ggtitle(variable_name)

    if (nchar_labels(to_plot[[variable_name]]) > 60) {
        fig <- fig + theme(
            axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
        )
    }

    print(fig)
    cat(description)
}
```

</div>

### Numerical predictors {.tab-display .unnumbered}

<div class="code-block">

```{r}
# In the later analysis, the numeric variables with only a few values are
# treated as discrete, while than those containing many variables are treated as
# continuous.  In the current code block, bin selection for the two types of
# numeric variables is done differently

discrete_numeric <- c('OverallQual', 'OverallCond', 'BsmtFullBath',
                      'BsmtHalfBath', 'FullBath', 'HalfBath',
                      'BedroomAbvGr', 'KitchenAbvGr', 'TotRmsAbvGrd',
                      'Fireplaces', 'GarageCars', 'MoSold',
                      'YrSold')

numeric_predictors <- setdiff(
    colnames(train_data),
    c(nominal_predictors, 'Id', 'SalePrice')
)

for (variable_name in numeric_predictors) {
    description <- variable_descriptions[[variable_name]]
    to_plot <- select(train_data, all_of(variable_name)) %>%
        drop_na()

    fig <- ggplot(to_plot, aes_string(x = variable_name)) +
        ggtitle(variable_name)

    if (variable_name %in% discrete_numeric) {
        # Select a bin for each value if we only have a few values.
        values <- to_plot[[variable_name]]
        max_value <- max(values, na.rm = T)
        min_value <- min(values, na.rm = T) - 1
        label_breaks <- min_value:max_value
        bin_breaks <- 0.5 + label_breaks
        fig <- fig +
            geom_histogram(fill = 'navyblue', breaks = bin_breaks) +
            scale_x_continuous(breaks = label_breaks)
    } else {
        # Otherwise use the default number of bins.
        fig <- fig + geom_histogram(fill = 'navyblue', bins = 30)
    }

    print(fig)
    cat(description)
}
```

</div>

## Variable associations

### Which predictors can explain the variance in the target? {.tabset}

#### Summary {.unnumbered}

ANOVA ($\eta^2$) used for categorical predictors.

  - Numerical predictors with only a few values treated as categorical.

$R^2$ used for continuous numerical predictors.

  - Numerical predictors with many values treated as continuous.

#### Categorical predictors {.tab-display .unnumbered}

<div class="code-block">

```{r}
categorical_predictors <- c(nominal_predictors, discrete_numeric)
sale_price <- train_data[['SalePrice']]
find_explained_variance <- function(variable_name, is_categorical) {
    variable <- train_data[[variable_name]]
    if (is_categorical) {
        variable <- as.factor(variable)
    }
    # For categorical variables, calculate eta squared, while for
    # continuous variable, calculate R squared.  Within R, these can both be
    # obtained from the lm model by executing the summary command and then
    # extracting the element r.squared.
    #
    # Explanation:  The command aov used for ANOVA in R is a wrapper to lm that
    # provides a summary in the traditional form for analysis of variance.  This
    # summary doesn't include eta squared.  However, the value is available as
    # r.squared from the summary for lm.  So if aov is used to generate the
    # model, then eta squared is available as summary.lm(model)$r.squared.
    model <- lm(sale_price ~ variable)
    return(summary(model)$r.squared)
}
eta_squared <- sapply(categorical_predictors, find_explained_variance,
                      is_categorical = T)
eta_squared_df <- data.frame(name = categorical_predictors,
                             eta.squared = eta_squared) %>%
    arrange(desc(eta.squared)) %>%
    rename(`eta squared` = eta.squared)
datatable(eta_squared_df, rownames = F,
          options = list(
              columnDefs = list(table_alignment),
              digits = 3
          )) %>%
    formatRound(columns = 'eta squared', digits = 3)
```

</div>

#### Continuous predictors  {.tab-display .unnumbered}

<div class="code-block">

```{r}
continuous_predictors <- setdiff(numeric_predictors, categorical_predictors)
r_squared <- sapply(continuous_predictors, find_explained_variance,
                    is_categorical = F)
r_squared_df <- data.frame(name = continuous_predictors,
                           r.squared = r_squared) %>%
    arrange(desc(r.squared)) %>%
    rename(`R squared` = r.squared)
datatable(r_squared_df, rownames = F,
          options = list(
              columnDefs = list(table_alignment),
              digits = 3
          )) %>%
    formatRound(columns = 'R squared', digits = 3)
```

